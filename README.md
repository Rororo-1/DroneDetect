# DroneDetect
Тут представлена моя система виявлення та ідентифікації дронів.
Програма має виявляти дрон на зображені і ідентифіковувати його
## Данні
Я брав данні з keggle datasets. 
Цей набір складався з 9000 зображень дронів і 9000 міток до них.
Мітки мали структуру <class_id center_x center_y width height>, при  цьому class_id завжди 0, тож для моєї цілі потрібно було їх поділити на класи.
Набір містив наступні моделі дронів: shahed - 131, shahed - 136, orlan - 10, Techyon, mavic 3, zala - 42116E, Lancet, mojahed, superCam, zala - 42104M, granat-4, granat - 2, granat - 1, forpost
## Схема:
Завантаження данних → кластеризація → навчання моделі виявлення і ідентифікації → розгортання модельки
### Кластеризація
Я почав з підготовки данних, використав AUTOTUNE для паралельної обробки прикладів, аби пришвидшити роботу прогрпми.
Я змінив розмір зображень на 224х224, бо вирішив використовувати VGG16, яка добре працює з таким розміром. До того ж це зменшить використання оперативки. 
Також я використав preprocess_input для нормалізації замість ділення бітів на 255, адже VGG16 очіку є BGR канали і віднімання середніх значень ImageNetq.
Модель VGG16 я використав через те, що це непогана модель для виділення ознак, яка є легшою за ResNet50. До того ж VGG16 я вкористовував раніше, тож це виглядало, як найзручніший для мене варіант.
І якості pooling я використав avg, бо він бере середнє значення з вимірів на відміну від max, Який був би доречнішим при детекції, а не кластеризації. flatten дав би забагато параметрів, що сказалося б на швидкості подальшої обробки

Для кластеризації я використав KMeans - бо це база для кластеризації. Я обрав 13 класів, а не 14 як в датасеті, бо в shahed - 131, shahed - 136 різниця полягає лише в розмірі, тож я їх поєднав в один клас.
Після отримання результатів я перезаписав всі мітки в папці labels замінивши перше значення на кластер до якого юуло віднесено зображення
### Виявлення і ласифікація
Для цієї роботи я обрав модель YALO12 medium, оскільки виявлення буде відбуватись на пк, а не на мобільному пристрої medium була підходящим вибором за співвідношенням точність/легкість.
12 модель я обрав через те, що це найостанніша модель, що вийшла на данний момент. Може автоматично автоматизувати архітектуру під зажачу, що на мій погляд є великою перевагою.
Я вирішив використовувати розділення train_test_split, через те, що це максимально знайомий і комфортний для мене спосіб, що випадково ділить датасет.
### Розгортання

